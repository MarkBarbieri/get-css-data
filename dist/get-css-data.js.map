{"version":3,"file":"get-css-data.js","sources":["../src/get-urls.js","../src/get-css.js"],"sourcesContent":["// Functions\n// =============================================================================\n/**\n * Requests one-or-more URLs and returns array of data in order specified.\n * Provides callbacks error and success callbacks for each XMLHttpRequest.\n *\n * @param {array|string} url - Single URL or array of URLs to request\n * @param {object} [options] - Options object\n * @param {string} [options.mimeType] - Overrides MIME type returned by server\n * @param {function} [options.onComplete] - Callback after all xhr requests have\n * completed. Returns array of response text for each URL in order provided.\n * @param {function} [options.onError] - Callback on xhr error. Returns xhr\n * object, URL, and URL index.\n * @param {function} [options.onSuccess] - Callback on xhr success. Returns\n * xhr.responseText, URL, and URL index.\n */\nfunction getUrls(urls, options = {}) {\n    const settings = {\n        mimeType  : options.mimeType   || null,\n        onComplete: options.onComplete || Function.prototype,\n        onError   : options.onError    || Function.prototype,\n        onSuccess : options.onSuccess  || Function.prototype\n    };\n    const urlArray = Array.isArray(urls) ? urls : [urls];\n    const urlQueue = Array.apply(null, Array(urlArray.length)).map(x => null);\n\n    // Functions (Private)\n    // -------------------------------------------------------------------------\n    function onError(xhr, urlIndex) {\n        settings.onError(xhr, urlArray[urlIndex], urlIndex);\n    }\n\n    function onSuccess(responseText, urlIndex) {\n        urlQueue[urlIndex] = responseText;\n        settings.onSuccess(responseText, urlArray[urlIndex], urlIndex);\n\n        // Complete\n        if (urlQueue.indexOf(null) === -1) {\n            settings.onComplete(urlQueue);\n        }\n    }\n\n    // Main\n    // -------------------------------------------------------------------------\n    urlArray.forEach((url, i) => {\n        const parser = document.createElement('a');\n\n        parser.setAttribute('href', url);\n        parser.href = parser.href;\n\n        const isCrossDomain  = parser.host !== location.host;\n        const isSameProtocol = parser.protocol === location.protocol;\n\n        // IE 9 CORS\n        if (isCrossDomain && typeof XDomainRequest !== 'undefined') {\n            if (isSameProtocol) {\n                const xdr = new XDomainRequest();\n\n                // Event handlers must be assigned AFTER xdr.open\n                xdr.open('GET', url);\n\n                xdr.timeout = 0; // Prevent aborts/timeouts\n                xdr.onprogress = Function.prototype; // Prevent aborts/timeouts\n                xdr.ontimeout = Function.prototype; // Prevent aborts/timeouts\n                xdr.onload = function() {\n                    onSuccess(xdr.responseText, i);\n                };\n                xdr.onerror = function(err) {\n                    onError(xdr, i);\n                };\n\n                // Wrap in setTimeout to fix known issues wtih XDomainRequest\n                // when sending multiple requests\n                setTimeout(function() {\n                    xdr.send();\n                }, 0);\n            }\n            else {\n                // eslint-disable-next-line\n                console.log('Internet Explorer 9 Cross-Origin (CORS) requests must use the same protocol');\n                onError(null, i);\n            }\n        }\n        // Other\n        else {\n            const xhr = new XMLHttpRequest();\n\n            xhr.open('GET', url);\n\n            // overrideMimeType method not available in all browsers\n            if (settings.mimeType && xhr.overrideMimeType) {\n                xhr.overrideMimeType(settings.mimeType);\n            }\n\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    // Success\n                    if (xhr.status === 200) {\n                        onSuccess(xhr.responseText, i);\n                    }\n                    // Error\n                    else {\n                        onError(xhr, i);\n                    }\n                }\n            };\n\n            xhr.send();\n        }\n    });\n}\n\n\n// Export\n// =============================================================================\nexport default getUrls;\n","// Dependencies\n// =============================================================================\nimport getUrls  from './get-urls';\n\n\n// Functions\n// =============================================================================\n/**\n * Gets CSS data from <style> and <link> nodes (including @imports), then\n * returns data in order processed by DOM. Allows specifying nodes to\n * include/exclude and filtering CSS data using RegEx.\n *\n * @param {getCssOptions} [options={}] - The options object\n */\n/**\n * @typedef getCssOptions\n * @type {object}\n * @property {string} include - CSS selector matching <link> and <style> nodes\n * to include\n * @property {string} exclude - CSS selector matching <link> and <style> nodes\n * to exclude\n * @property {object} filter - Regular expression used to filter node CSS data.\n * Each block of CSS data is tested against the filter, and only matching data\n * is included.\n * @property {function} onComplete - Callback after all nodes have been\n * processed. Passes concatenated CSS text and array of CSS text in DOM order\n * as arguments.\n * @property {function} onError - Callback on each error. Passes the XHR object\n * for inspection, soure node reference, and the source URL that failed (either\n * a <link> href or an @import) as arguments\n * @property {function} onSuccess - Callback on each CSS node read. Passes CSS\n * text, source node reference, and the source URL (either a <link> href or an\n * import) as arguments.\n * @example\n *\n *   getCss({\n *     include: 'style,link[rel=\"stylesheet\"]', // default\n *     exclude: '[href=\"skip.css\"]',\n *     filter : /red/,\n *     onComplete(cssText, cssArray) {\n *       // ...\n *     },\n *     onError(xhr, node, url) {\n *       // ...\n *     },\n  *    onSuccess(cssText, node, url) {\n *       // ...\n *     }\n *   });\n */\nfunction getCss(options) {\n    const regex = {\n        // CSS comments\n        cssComments: /\\/\\*[\\s\\S]+?\\*\\//gm,\n        // CSS @import rules ($1: url)\n        cssImports : /(?:@import\\s*)(?:url\\(\\s*)?(?:['\"])([\\w\\-./ ]*)(?:['\"])(?:\\s*\\))?(?:[^;]*;)/igm\n    };\n    const settings = {\n        include   : options.include    || 'style,link[rel=\"stylesheet\"]',\n        exclude   : options.exclude    || null,\n        filter    : options.filter     || null,\n        onComplete: options.onComplete || Function.prototype,\n        onError   : options.onError    || Function.prototype,\n        onSuccess : options.onSuccess  || Function.prototype\n    };\n    const sourceNodes = Array.apply(null, document.querySelectorAll(settings.include)).filter(node => !matchesSelector(node, settings.exclude));\n    const cssQueue    = Array.apply(null, Array(sourceNodes.length)).map(x => null);\n\n    // Functions (Private)\n    // -------------------------------------------------------------------------\n    /**\n     * Handles the onComplete() callback after verifying that all CSS has been\n     * processed.\n     */\n    function handleComplete() {\n        const isComplete = cssQueue.indexOf(null) === -1;\n\n        if (isComplete) {\n            const cssText = cssQueue.join('');\n\n            settings.onComplete(cssText, cssQueue);\n        }\n    }\n\n    /**\n     * Handles the onError callback for failed XMLHttpRequests\n     *\n     * @param {object} xhr\n     * @param {string} url\n     * @param {number} cssIndex\n     * @param {object} node\n     */\n    function handleError(xhr, url, cssIndex, node) {\n        cssQueue[cssIndex] = '';\n\n        settings.onError(xhr, node, url);\n\n        handleComplete();\n    }\n\n    /**\n     * Processes CSS text, updates cssQueue, and triggers handleComplete()\n     * 1. Tests CSS against (optional) RegEx filter\n     * 2. Triggers onSuccess() callback and accepts modified cssText as return\n     * 3. Detects and resolves @import rules\n     * 4. Inserts final CSS into cssQueue\n     * 5. Triggers handleComplete() after processing is complete\n     *\n     * @param {string} cssText - CSS text to be processed\n     * @param {number} cssIndex - cssQueue index to store final CSS\n     * @param {object} node - CSS source <link> or <style> node\n     * @param {string} sourceUrl - The base URL for resolving relative @imports\n     * @param {string} importUrl - The @import source URL (if applicable)\n     */\n    function handleSuccess(cssText, cssIndex, node, sourceUrl, importUrl) {\n        // Filter: Pass\n        if (!settings.filter || settings.filter.test(cssText)) {\n            // Store the return value of the onSuccess callback. This allows\n            // modifying cssText before adding to cssQueue.\n            const returnVal = settings.onSuccess(cssText, node, importUrl || sourceUrl);\n\n            // Set cssText to return value (if provided)\n            cssText = returnVal === false ? '' : returnVal || cssText;\n\n            // Get @import rules from cssText. CSS comments are removed\n            // to avoid @import statements in comments from being processed.\n            const importRules = cssText.replace(regex.cssComments, '').match(regex.cssImports);\n\n            // Has @imports\n            if (importRules) {\n                let importUrls = importRules.map(decl => decl.replace(regex.cssImports, '$1'));\n\n                // Convert relative importUrls to absolute urls using\n                // sourceUrl as base.\n                importUrls = importUrls.map(url => getFullUrl(url, sourceUrl));\n\n                getUrls(importUrls, {\n                    onError(xhr, url, urlIndex) {\n                        handleError(xhr, url, cssIndex, node);\n                    },\n                    onSuccess(importText, url, urlIndex) {\n                        const importDecl = importRules[urlIndex];\n                        const importUrl  = importUrls[urlIndex];\n                        const newCssText = cssText.replace(importDecl, importText);\n\n                        handleSuccess(newCssText, cssIndex, node, url, importUrl);\n                    }\n                });\n            }\n            // No @imports\n            else {\n                cssQueue[cssIndex] = cssText;\n                handleComplete();\n            }\n        }\n        // Filter: Fail\n        else {\n            cssQueue[cssIndex] = '';\n            handleComplete();\n        }\n    }\n\n\n    // Main\n    // -------------------------------------------------------------------------\n    sourceNodes.forEach((node, i) => {\n        const linkHref = node.getAttribute('href');\n        const linkRel  = node.getAttribute('rel');\n        const isLink   = node.nodeName === 'LINK' && linkHref && linkRel && linkRel.toLowerCase() === 'stylesheet';\n        const isStyle  = node.nodeName === 'STYLE';\n\n        if (isLink) {\n            getUrls(linkHref, {\n                mimeType: 'text/css',\n                onError(xhr, url, urlIndex) {\n                    handleError(xhr, url, i, node);\n                },\n                onSuccess(cssText, url, urlIndex) {\n                    // Convert relative linkHref to absolute url to use as\n                    // the base URL for @import statements.\n                    // const sourceUrl = new URLParse(linkHref, location.href).href;\n                    const sourceUrl = getFullUrl(linkHref, location.href);\n\n                    handleSuccess(cssText, i, node, sourceUrl);\n                }\n            });\n        }\n        else if (isStyle) {\n            handleSuccess(node.textContent, i, node, location.href);\n        }\n        else {\n            cssQueue[i] = '';\n            handleComplete();\n        }\n    });\n}\n\n/**\n * Returns fully qualified URL from relative URL and (optional) base URL\n *\n * @param {any} url\n * @param {any} [base=location.href]\n * @returns\n */\nfunction getFullUrl(url, base = location.href) {\n    const d = document.implementation.createHTMLDocument('');\n    const b = d.createElement('base');\n    const a = d.createElement('a');\n\n    d.head.appendChild(b);\n    d.body.appendChild(a);\n    b.href = base;\n    a.href = url;\n\n    return a.href;\n}\n\n/**\n * Ponyfill for native Element.matches method\n *\n * @param {object} elm - The element to test\n * @param {string} selector - The CSS selector to test against\n * @returns {boolean}\n */\nfunction matchesSelector(elm, selector) {\n    /* istanbul ignore next */\n    const matches = elm.matches || elm.matchesSelector || elm.webkitMatchesSelector || elm.mozMatchesSelector || elm.msMatchesSelector || elm.oMatchesSelector;\n\n    return matches.call(elm, selector);\n}\n\n\n// Export\n// =============================================================================\nexport default getCss;\n"],"names":["getUrls","urls","options","settings","mimeType","onComplete","Function","prototype","onError","onSuccess","urlArray","Array","isArray","urlQueue","apply","length","map","xhr","urlIndex","responseText","indexOf","forEach","url","i","parser","document","createElement","setAttribute","href","isCrossDomain","host","location","isSameProtocol","protocol","XDomainRequest","xdr","open","timeout","onprogress","ontimeout","onload","onerror","err","send","log","XMLHttpRequest","overrideMimeType","onreadystatechange","readyState","status","getFullUrl","base","d","implementation","createHTMLDocument","b","a","head","appendChild","body","regex","include","exclude","filter","sourceNodes","querySelectorAll","elm","node","selector","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","call","cssQueue","handleComplete","cssText","join","handleError","cssIndex","handleSuccess","sourceUrl","importUrl","test","returnVal","importRules","replace","cssComments","match","cssImports","importUrls","decl","importText","importDecl","linkHref","getAttribute","linkRel","isLink","nodeName","toLowerCase","isStyle","textContent"],"mappings":"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"}