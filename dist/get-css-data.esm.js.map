{"version":3,"file":"get-css-data.esm.js","sources":["../src/get-urls.js","../src/get-css.js"],"sourcesContent":["// Functions\n// =============================================================================\n/**\n * Requests one-or-more URLs and returns array of data in order specified.\n * Provides callbacks error and success callbacks for each XMLHttpRequest.\n *\n * @param {array|string} url Single URL or array of URLs to request\n * @param {object}      [options] Options object\n * @param {string}      [options.mimeType] Overrides MIME type returned by\n *                      server\n * @param {function}    [options.onBeforeSend] Callback before each request is\n *                      sent. Passes 1) the xhr object, 2) the URL, and 3) the\n *                      URL index as arguments.\n * @param {function}    [options.onSuccess] Callback on xhr success. Passes 1)\n *                      xhr response text, 2) the URL, and 3) the URL index as\n *                      arguments.\n * @param {function}    [options.onError] Callback on xhr error. Passes 1) the\n *                      xhr object, 2) the URL, 3) the URL index as arguments.\n * @param {function}    [options.onComplete] Callback after all requests have\n *                      completed. Passes 1) an array of response text for each\n *                      URL in order provided as an argument.\n */\nfunction getUrls(urls, options = {}) {\n    const settings = {\n        mimeType    : options.mimeType     || null,\n        onBeforeSend: options.onBeforeSend || Function.prototype,\n        onSuccess   : options.onSuccess    || Function.prototype,\n        onError     : options.onError      || Function.prototype,\n        onComplete  : options.onComplete   || Function.prototype\n    };\n    const urlArray = Array.isArray(urls) ? urls : [urls];\n    const urlQueue = Array.apply(null, Array(urlArray.length)).map(x => null);\n\n    // Functions (Private)\n    // -------------------------------------------------------------------------\n    function onError(xhr, urlIndex) {\n        settings.onError(xhr, urlArray[urlIndex], urlIndex);\n    }\n\n    function onSuccess(responseText, urlIndex) {\n        urlQueue[urlIndex] = responseText;\n        settings.onSuccess(responseText, urlArray[urlIndex], urlIndex);\n\n        // Complete\n        if (urlQueue.indexOf(null) === -1) {\n            settings.onComplete(urlQueue);\n        }\n    }\n\n    // Main\n    // -------------------------------------------------------------------------\n    urlArray.forEach((url, i) => {\n        const parser = document.createElement('a');\n\n        parser.setAttribute('href', url);\n        parser.href = parser.href;\n\n        const isCrossDomain  = parser.host !== location.host;\n        const isSameProtocol = parser.protocol === location.protocol;\n\n        // IE 9 CORS\n        if (isCrossDomain && typeof XDomainRequest !== 'undefined') {\n            if (isSameProtocol) {\n                const xdr = new XDomainRequest();\n\n                // Event handlers must be assigned AFTER xdr.open\n                xdr.open('GET', url);\n\n                xdr.timeout = 0; // Prevent aborts/timeouts\n                xdr.onprogress = Function.prototype; // Prevent aborts/timeouts\n                xdr.ontimeout = Function.prototype; // Prevent aborts/timeouts\n                xdr.onload = function() {\n                    onSuccess(xdr.responseText, i);\n                };\n                xdr.onerror = function(err) {\n                    onError(xdr, i);\n                };\n\n                // Wrap in setTimeout to fix known issues wtih XDomainRequest\n                // when sending multiple requests\n                setTimeout(function() {\n                    xdr.send();\n                }, 0);\n            }\n            else {\n                // eslint-disable-next-line\n                console.log('Internet Explorer 9 Cross-Origin (CORS) requests must use the same protocol');\n                onError(null, i);\n            }\n        }\n        // Other\n        else {\n            const xhr = new XMLHttpRequest();\n\n            xhr.open('GET', url);\n\n            // overrideMimeType method not available in all browsers\n            if (settings.mimeType && xhr.overrideMimeType) {\n                xhr.overrideMimeType(settings.mimeType);\n            }\n\n            settings.onBeforeSend(xhr, url, i);\n\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    // Success\n                    if (xhr.status === 200) {\n                        onSuccess(xhr.responseText, i);\n                    }\n                    // Error\n                    else {\n                        onError(xhr, i);\n                    }\n                }\n            };\n\n            xhr.send();\n        }\n    });\n}\n\n\n// Export\n// =============================================================================\nexport default getUrls;\n","// Dependencies\n// =============================================================================\nimport getUrls from './get-urls';\n\n\n// Functions (Public)\n// =============================================================================\n/**\n * Gets CSS data from <style> and <link> nodes (including @imports), then\n * returns data in order processed by DOM. Allows specifying nodes to\n * include/exclude and filtering CSS data using RegEx.\n *\n * @preserve\n * @param {object}   [options] The options object\n * @param {string}   [options.include] CSS selector matching <link> and <style>\n *                   nodes to include\n * @param {string}   [options.exclude] CSS selector matching <link> and <style>\n *                   nodes to exclude\n * @param {object}   [options.filter] Regular expression used to filter node CSS\n *                   data. Each block of CSS data is tested against the filter,\n *                   and only matching data is included.\n * @param {function} [options.onBeforeSend] Callback before XHR is sent. Passes\n *                   1) the XHR object, 2) source node reference, and 3) the\n *                   source URL as arguments.\n * @param {function} [options.onSuccess] Callback on each CSS node read. Passes\n *                   1) CSS text, 2) source node reference, and 3) the source\n *                   URL as arguments.\n * @param {function} [options.onError] Callback on each error. Passes 1) the XHR\n *                   object for inspection, 2) soure node reference, and 3) the\n *                   source URL that failed (either a <link> href or an @import)\n *                   as arguments\n * @param {function} [options.onComplete] Callback after all nodes have been\n *                   processed. Passes 1) concatenated CSS text, 2) an array of\n *                   CSS text in DOM order, and 3) an array of nodes in DOM\n *                   order as arguments.\n *\n * @example\n *\n *   getCssData({\n *     include: 'style,link[rel=\"stylesheet\"]', // default\n *     exclude: '[href=\"skip.css\"]',\n *     filter : /red/,\n *     onBeforeSend(xhr, node, url) {\n *       // ...\n *     }\n *     onSuccess(cssText, node, url) {\n *       // ...\n *     }\n *     onError(xhr, node, url) {\n *       // ...\n *     },\n *     onComplete(cssText, cssArray) {\n *       // ...\n *     },\n *   });\n */\nfunction getCssData(options) {\n    const regex = {\n        // CSS comments\n        cssComments: /\\/\\*[\\s\\S]+?\\*\\//g,\n        // CSS @import rules ($1: url)\n        cssImports : /(?:@import\\s*)(?:url\\(\\s*)?(?:['\"])([^'\"]*)(?:['\"])(?:\\s*\\))?(?:[^;]*;)/g\n    };\n    const settings = {\n        include     : options.include      || 'style,link[rel=\"stylesheet\"]',\n        exclude     : options.exclude      || null,\n        filter      : options.filter       || null,\n        onBeforeSend: options.onBeforeSend || Function.prototype,\n        onSuccess   : options.onSuccess    || Function.prototype,\n        onError     : options.onError      || Function.prototype,\n        onComplete  : options.onComplete   || Function.prototype\n    };\n    const sourceNodes = Array.apply(null, document.querySelectorAll(settings.include)).filter(node => !matchesSelector(node, settings.exclude));\n    const cssArray    = Array.apply(null, Array(sourceNodes.length)).map(x => null);\n\n    /**\n     * Handles the onComplete() callback after verifying that all CSS has been\n     * processed.\n     */\n    function handleComplete() {\n        const isComplete = cssArray.indexOf(null) === -1;\n\n        if (isComplete) {\n            const cssText = cssArray.join('');\n\n            settings.onComplete(cssText, cssArray, sourceNodes);\n        }\n    }\n\n    /**\n     * Processes CSS text, updates cssArray, and triggers handleComplete()\n     * 1. Passes CSS to resolveImports\n     * 2. Triggers onError() callback for each @import error\n     * 3. Tests resolved CSS against (optional) RegEx filter\n     * 4. Triggers onSuccess() callback and accepts modified cssText as return\n     * 5. Inserts final CSS into cssArray\n     * 6. Triggers handleComplete() after processing is complete\n     *\n     * @param {string} cssText CSS text to be processed\n     * @param {number} cssIndex cssArray index to store final CSS\n     * @param {object} node CSS source <link> or <style> node\n     * @param {string} sourceUrl The URL containing the source node\n     */\n    function handleSuccess(cssText, cssIndex, node, sourceUrl) {\n        resolveImports(cssText, node, sourceUrl, function(resolvedCssText, errorData) {\n            if (cssArray[cssIndex] === null) {\n                // Trigger onError for each error item\n                errorData.forEach(data => settings.onError(data.xhr, node, data.url));\n\n                // Filter: Pass\n                if (!settings.filter || settings.filter.test(resolvedCssText)) {\n                    // Store return value of the onSuccess callback. This allows\n                    // modifying resolvedCssText before adding to cssArray.\n                    const returnVal = settings.onSuccess(resolvedCssText, node, sourceUrl);\n\n                    // Store return value (if provided) or resolvedCssText\n                    cssArray[cssIndex] = returnVal === false ? '' : returnVal || resolvedCssText;\n                }\n                // Filter: Fail\n                else {\n                    cssArray[cssIndex] = '';\n                }\n\n                handleComplete();\n            }\n        });\n    }\n\n    /**\n     * Parses CSS and returns an object containing @import related data.\n     *\n     * @param {any} cssText CSS text to be processed\n     * @param {any} baseUrl Base URL used to resolve relative @import URLs\n     * @param {any} [ignoreRules=[]]\n     * @returns {object}\n     */\n    function parseImportData(cssText, baseUrl, ignoreRules = []) {\n        const importData = {};\n\n        // @import rules\n        // Ex: @import \"file.css\";\n        importData.rules = (cssText\n            // Remove comments to avoid processing @import in comments\n            .replace(regex.cssComments, '')\n            // Find all @import rules\n            .match(regex.cssImports)\n            // Force empty array if no match\n            || [])\n            // Remove rules found in ignoreRules array\n            .filter(rule => ignoreRules.indexOf(rule) === -1);\n\n        // @import urls\n        // Ex: file.css\n        importData.urls = importData.rules.map(rule => rule.replace(regex.cssImports, '$1'));\n\n        // Absolute @import urls\n        // Ex: /path/to/file.css\n        importData.absoluteUrls = importData.urls.map(url => getFullUrl(url, baseUrl));\n\n        // Absolute @import rules\n        // Ex: @import \"/path/to/file.css\";\n        importData.absoluteRules = importData.rules.map((rule, i) => {\n            const oldUrl = importData.urls[i];\n            const newUrl = getFullUrl(importData.absoluteUrls[i], baseUrl);\n\n            return rule.replace(oldUrl, newUrl);\n        });\n\n        return importData;\n    }\n\n    /**\n     * Recursively parses CSS for @import rules, fetches data for each import\n     * URL, replaces the @rule the fetched data, then returns the resolved CSS\n     * via a callback function.\n     *\n     * @param {string}   cssText CSS text to be processed\n     * @param {object}   node CSS source <link> or <style> node\n     * @param {string}   baseUrl Base URL used to resolve relative @import URLs\n     * @param {function} callbackFn Callback function to trigger on complete.\n     *                   Passes 1) the resolves CSS and 2) an array of error\n     *                   objects as arguments.\n     */\n    function resolveImports(cssText, node, baseUrl, callbackFn, __errorData = [], __errorRules = []) {\n        const importData = parseImportData(cssText, baseUrl, __errorRules);\n\n        // Has @imports\n        if (importData.rules.length) {\n            getUrls(importData.absoluteUrls, {\n                onBeforeSend(xhr, url, urlIndex) {\n                    settings.onBeforeSend(xhr, node, url);\n                },\n                onError(xhr, url, urlIndex) {\n                    __errorData.push({ xhr, url });\n                    __errorRules.push(importData.rules[urlIndex]);\n\n                    resolveImports(cssText, node, baseUrl, callbackFn, __errorData, __errorRules);\n                },\n                onComplete(responseArray) {\n                    responseArray.forEach((importText, i) => {\n                        const responseImportData = parseImportData(importText, importData.absoluteUrls[i], __errorRules);\n\n                        // Replace relative @import rules with absolute rules\n                        responseImportData.rules.forEach((rule, i) => {\n                            importText = importText.replace(rule, responseImportData.absoluteRules[i]);\n                        });\n\n                        cssText = cssText.replace(importData.rules[i], importText);\n                    });\n\n                    resolveImports(cssText, node, baseUrl, callbackFn, __errorData, __errorRules);\n                }\n            });\n        }\n        // No @imports\n        else {\n            callbackFn(cssText, __errorData);\n        }\n    }\n\n    // Main\n    // -------------------------------------------------------------------------\n    if (sourceNodes.length) {\n        sourceNodes.forEach((node, i) => {\n            const linkHref = node.getAttribute('href');\n            const linkRel  = node.getAttribute('rel');\n            const isLink   = node.nodeName === 'LINK' && linkHref && linkRel && linkRel.toLowerCase() === 'stylesheet';\n            const isStyle  = node.nodeName === 'STYLE';\n\n            if (isLink) {\n                getUrls(linkHref, {\n                    mimeType: 'text/css',\n                    onBeforeSend(xhr, url, urlIndex) {\n                        settings.onBeforeSend(xhr, node, url);\n                    },\n                    onSuccess(cssText, url, urlIndex) {\n                        // Convert relative linkHref to absolute url\n                        const sourceUrl = getFullUrl(linkHref, location.href);\n\n                        handleSuccess(cssText, i, node, sourceUrl);\n                    },\n                    onError(xhr, url, urlIndex) {\n                        cssArray[i] = '';\n                        settings.onError(xhr, node, url);\n                        handleComplete();\n                    }\n                });\n            }\n            else if (isStyle) {\n                handleSuccess(node.textContent, i, node, location.href);\n            }\n            else {\n                cssArray[i] = '';\n                handleComplete();\n            }\n        });\n    }\n    else {\n        settings.onComplete('', []);\n    }\n}\n\n\n// Functions (Private)\n// =============================================================================\n/**\n * Returns fully qualified URL from relative URL and (optional) base URL\n *\n * @param {any} url\n * @param {any} [base=location.href]\n * @returns\n */\nfunction getFullUrl(url, base = location.href) {\n    const d = document.implementation.createHTMLDocument('');\n    const b = d.createElement('base');\n    const a = d.createElement('a');\n\n    d.head.appendChild(b);\n    d.body.appendChild(a);\n    b.href = base;\n    a.href = url;\n\n    return a.href;\n}\n\n/**\n * Ponyfill for native Element.matches method\n *\n * @param   {object} elm The element to test\n * @param   {string} selector The CSS selector to test against\n * @returns {boolean}\n */\nfunction matchesSelector(elm, selector) {\n    /* istanbul ignore next */\n    const matches = elm.matches || elm.matchesSelector || elm.webkitMatchesSelector || elm.mozMatchesSelector || elm.msMatchesSelector || elm.oMatchesSelector;\n\n    return matches.call(elm, selector);\n}\n\n\n// Export\n// =============================================================================\nexport default getCssData;\n"],"names":["getUrls","urls","options","settings","mimeType","onBeforeSend","Function","prototype","onSuccess","onError","onComplete","urlArray","Array","isArray","urlQueue","apply","length","map","xhr","urlIndex","responseText","indexOf","forEach","url","i","parser","document","createElement","setAttribute","href","isCrossDomain","host","location","isSameProtocol","protocol","XDomainRequest","xdr","open","timeout","onprogress","ontimeout","onload","onerror","err","send","log","XMLHttpRequest","overrideMimeType","onreadystatechange","readyState","status","getCssData","regex","include","exclude","filter","sourceNodes","querySelectorAll","matchesSelector","node","cssArray","handleComplete","isComplete","cssText","join","handleSuccess","cssIndex","sourceUrl","resolvedCssText","errorData","data","test","returnVal","parseImportData","baseUrl","ignoreRules","importData","rules","replace","cssComments","match","cssImports","rule","absoluteUrls","getFullUrl","absoluteRules","oldUrl","newUrl","resolveImports","callbackFn","__errorData","__errorRules","push","responseArray","importText","responseImportData","linkHref","getAttribute","linkRel","isLink","nodeName","toLowerCase","isStyle","textContent","base","d","implementation","createHTMLDocument","b","a","head","appendChild","body","elm","selector","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","call"],"mappings":"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"}