{"version":3,"file":"get-css-data.esm.min.js","sources":["../src/get-urls.js","../src/get-css.js"],"sourcesContent":["// Functions\n// =============================================================================\n/**\n * Requests one-or-more URLs and returns array of data in order specified.\n * Provides callbacks error and success callbacks for each XMLHttpRequest.\n *\n * @param {array|string} url - Single URL or array of URLs to request\n * @param {object} [options] - Options object\n * @param {string} [options.mimeType] - Overrides MIME type returned by server\n * @param {function} [options.onComplete] - Callback after all xhr requests have\n * completed. Returns array of response text for each URL in order provided.\n * @param {function} [options.onError] - Callback on xhr error. Returns xhr\n * object, URL, and URL index.\n * @param {function} [options.onSuccess] - Callback on xhr success. Returns\n * xhr.responseText, URL, and URL index.\n */\nfunction getUrls(urls, options = {}) {\n    const settings = {\n        mimeType  : options.mimeType   || null,\n        onComplete: options.onComplete || Function.prototype,\n        onError   : options.onError    || Function.prototype,\n        onSuccess : options.onSuccess  || Function.prototype\n    };\n    const urlArray = Array.isArray(urls) ? urls : [urls];\n    const urlQueue = Array.apply(null, Array(urlArray.length)).map(x => null);\n\n    // Functions (Private)\n    // -------------------------------------------------------------------------\n    function onError(xhr, urlIndex) {\n        settings.onError(xhr, urlArray[urlIndex], urlIndex);\n    }\n\n    function onSuccess(responseText, urlIndex) {\n        urlQueue[urlIndex] = responseText;\n        settings.onSuccess(responseText, urlArray[urlIndex], urlIndex);\n\n        // Complete\n        if (urlQueue.indexOf(null) === -1) {\n            settings.onComplete(urlQueue);\n        }\n    }\n\n    // Main\n    // -------------------------------------------------------------------------\n    urlArray.forEach((url, i) => {\n        const parser = document.createElement('a');\n\n        parser.setAttribute('href', url);\n        parser.href = parser.href;\n\n        const isCrossDomain  = parser.host !== location.host;\n        const isSameProtocol = parser.protocol === location.protocol;\n\n        // IE 9 CORS\n        if (isCrossDomain && typeof XDomainRequest !== 'undefined') {\n            if (isSameProtocol) {\n                const xdr = new XDomainRequest();\n\n                // Event handlers must be assigned AFTER xdr.open\n                xdr.open('GET', url);\n\n                xdr.timeout = 0; // Prevent aborts/timeouts\n                xdr.onprogress = Function.prototype; // Prevent aborts/timeouts\n                xdr.ontimeout = Function.prototype; // Prevent aborts/timeouts\n                xdr.onload = function() {\n                    onSuccess(xdr.responseText, i);\n                };\n                xdr.onerror = function(err) {\n                    onError(xdr, i);\n                };\n\n                // Wrap in setTimeout to fix known issues wtih XDomainRequest\n                // when sending multiple requests\n                setTimeout(function() {\n                    xdr.send();\n                }, 0);\n            }\n            else {\n                // eslint-disable-next-line\n                console.log('Internet Explorer 9 Cross-Origin (CORS) requests must use the same protocol');\n                onError(null, i);\n            }\n        }\n        // Other\n        else {\n            const xhr = new XMLHttpRequest();\n\n            xhr.open('GET', url);\n\n            // overrideMimeType method not available in all browsers\n            if (settings.mimeType && xhr.overrideMimeType) {\n                xhr.overrideMimeType(settings.mimeType);\n            }\n\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    // Success\n                    if (xhr.status === 200) {\n                        onSuccess(xhr.responseText, i);\n                    }\n                    // Error\n                    else {\n                        onError(xhr, i);\n                    }\n                }\n            };\n\n            xhr.send();\n        }\n    });\n}\n\n\n// Export\n// =============================================================================\nexport default getUrls;\n","// Dependencies\n// =============================================================================\nimport getUrls from './get-urls';\n\n\n// Functions (Public)\n// =============================================================================\n/**\n * Gets CSS data from <style> and <link> nodes (including @imports), then\n * returns data in order processed by DOM. Allows specifying nodes to\n * include/exclude and filtering CSS data using RegEx.\n *\n * @preserve\n * @param {object} [options={}] - The options object\n * @param {string} options.include - CSS selector matching <link> and <style>\n * nodes to include\n * @param {string} options.exclude - CSS selector matching <link> and <style>\n * nodes to exclude\n * @param {object} options.filter - Regular expression used to filter node CSS\n * data. Each block of CSS data is tested against the filter, and only matching\n * data is included.\n * @param {function} options.onComplete - Callback after all nodes have been\n * processed. Passes 1) concatenated CSS text, 2) an array of CSS text in DOM\n * order, and 3) an array of nodes in DOM order as arguments.\n * @param {function} options.onError - Callback on each error. Passes 1) the XHR\n * object for inspection, 2) soure node reference, and 3) the source URL that\n * failed (either a <link> href or an @import) as arguments\n * @param {function} options.onSuccess - Callback on each CSS node read. Passes\n * 1) CSS text, 2) source node reference, and 3) the source URL (either a <link>\n *    href or an import) as arguments.\n * @example\n *\n *   getCssData({\n *     include: 'style,link[rel=\"stylesheet\"]', // default\n *     exclude: '[href=\"skip.css\"]',\n *     filter : /red/,\n *     onComplete(cssText, cssArray) {\n *       // ...\n *     },\n *     onError(xhr, node, url) {\n *       // ...\n *     },\n *     onSuccess(cssText, node, url) {\n *       // ...\n *     }\n *   });\n */\nfunction getCssData(options) {\n    const regex = {\n        // CSS comments\n        cssComments: /\\/\\*[\\s\\S]+?\\*\\//g,\n        // CSS @import rules ($1: url)\n        cssImports : /(?:@import\\s*)(?:url\\(\\s*)?(?:['\"])([^'\"]*)(?:['\"])(?:\\s*\\))?(?:[^;]*;)/g\n    };\n    const settings = {\n        include   : options.include    || 'style,link[rel=\"stylesheet\"]',\n        exclude   : options.exclude    || null,\n        filter    : options.filter     || null,\n        onComplete: options.onComplete || Function.prototype,\n        onError   : options.onError    || Function.prototype,\n        onSuccess : options.onSuccess  || Function.prototype\n    };\n    const sourceNodes = Array.apply(null, document.querySelectorAll(settings.include)).filter(node => !matchesSelector(node, settings.exclude));\n    const cssArray    = Array.apply(null, Array(sourceNodes.length)).map(x => null);\n\n    /**\n     * Handles the onComplete() callback after verifying that all CSS has been\n     * processed.\n     */\n    function handleComplete() {\n        const isComplete = cssArray.indexOf(null) === -1;\n\n        if (isComplete) {\n            const cssText = cssArray.join('');\n\n            settings.onComplete(cssText, cssArray, sourceNodes);\n        }\n    }\n\n    /**\n     * Processes CSS text, updates cssArray, and triggers handleComplete()\n     * 1. Passes CSS to resolveImports\n     * 2. Triggers onError() callback for each @import error\n     * 3. Tests resolved CSS against (optional) RegEx filter\n     * 4. Triggers onSuccess() callback and accepts modified cssText as return\n     * 5. Inserts final CSS into cssArray\n     * 6. Triggers handleComplete() after processing is complete\n     *\n     * @param {string} cssText - CSS text to be processed\n     * @param {number} cssIndex - cssArray index to store final CSS\n     * @param {object} node - CSS source <link> or <style> node\n     * @param {string} sourceUrl - The URL containing the source node\n     */\n    function handleSuccess(cssText, cssIndex, node, sourceUrl) {\n        resolveImports(cssText, sourceUrl, function(resolvedCssText, errorData) {\n            if (cssArray[cssIndex] === null) {\n                // Trigger onError for each error item\n                errorData.forEach(data => settings.onError(data.xhr, node, data.url));\n\n                // Filter: Pass\n                if (!settings.filter || settings.filter.test(resolvedCssText)) {\n                    // Store return value of the onSuccess callback. This allows\n                    // modifying resolvedCssText before adding to cssArray.\n                    const returnVal = settings.onSuccess(resolvedCssText, node, sourceUrl);\n\n                    // Store return value (if provided) or resolvedCssText\n                    cssArray[cssIndex] = returnVal === false ? '' : returnVal || resolvedCssText;\n                }\n                // Filter: Fail\n                else {\n                    cssArray[cssIndex] = '';\n                }\n\n                handleComplete();\n            }\n        });\n    }\n\n    /**\n     * Recursively parses CSS for @import rules, fetches data for each import\n     * URL, replaces the @rule the fetched data, then returns the resolved CSS\n     * via a callback function.\n     *\n     * @param {string} cssText - CSS text to be processed\n     * @param {string} baseUrl - Base URL used to resolve relative @import URLs\n     * @param {function} callbackFn - Callback function to trigger on complete.\n     * Passes 1) the resolves CSS and 2) an array of error objects as arguments.\n     */\n    function resolveImports(cssText, baseUrl, callbackFn, __errorData = [], __errorRules = []) {\n        let importRules = cssText\n            // Remove comments to avoid processing @import in comments\n            .replace(regex.cssComments, '')\n            // Find all @import rules\n            .match(regex.cssImports);\n\n        // Remove rules found in __errorRules array\n        importRules = (importRules || []).filter(rule => __errorRules.indexOf(rule) === -1);\n\n        // Has @imports\n        if (importRules.length) {\n            const importUrls = importRules\n                // Get URLs from @import rules\n                .map(decl => decl.replace(regex.cssImports, '$1'))\n                // Convert to absolute urls\n                .map(url => getFullUrl(url, baseUrl));\n\n            getUrls(importUrls, {\n                onError(xhr, url, urlIndex) {\n                    __errorData.push({ xhr, url });\n                    __errorRules.push(importRules[urlIndex]);\n\n                    resolveImports(cssText, baseUrl, callbackFn, __errorData, __errorRules);\n                },\n                onSuccess(importText, url, urlIndex) {\n                    const importDecl = importRules[urlIndex];\n                    const newCssText = cssText.replace(importDecl, importText);\n\n                    resolveImports(newCssText, url, callbackFn, __errorData, __errorRules);\n                }\n            });\n        }\n        // No @imports\n        else {\n            callbackFn(cssText, __errorData);\n        }\n    }\n\n    // Main\n    // -------------------------------------------------------------------------\n    if (sourceNodes.length) {\n        sourceNodes.forEach((node, i) => {\n            const linkHref = node.getAttribute('href');\n            const linkRel  = node.getAttribute('rel');\n            const isLink   = node.nodeName === 'LINK' && linkHref && linkRel && linkRel.toLowerCase() === 'stylesheet';\n            const isStyle  = node.nodeName === 'STYLE';\n\n            if (isLink) {\n                getUrls(linkHref, {\n                    mimeType: 'text/css',\n                    onError(xhr, url, urlIndex) {\n                        cssArray[i] = '';\n                        settings.onError(xhr, node, url);\n                        handleComplete();\n                    },\n                    onSuccess(cssText, url, urlIndex) {\n                        // Convert relative linkHref to absolute url\n                        const sourceUrl = getFullUrl(linkHref, location.href);\n\n                        handleSuccess(cssText, i, node, sourceUrl);\n                    }\n                });\n            }\n            else if (isStyle) {\n                handleSuccess(node.textContent, i, node, location.href);\n            }\n            else {\n                cssArray[i] = '';\n                handleComplete();\n            }\n        });\n    }\n    else {\n        settings.onComplete('', []);\n    }\n}\n\n\n// Functions (Private)\n// =============================================================================\n/**\n * Returns fully qualified URL from relative URL and (optional) base URL\n *\n * @param {any} url\n * @param {any} [base=location.href]\n * @returns\n */\nfunction getFullUrl(url, base = location.href) {\n    const d = document.implementation.createHTMLDocument('');\n    const b = d.createElement('base');\n    const a = d.createElement('a');\n\n    d.head.appendChild(b);\n    d.body.appendChild(a);\n    b.href = base;\n    a.href = url;\n\n    return a.href;\n}\n\n/**\n * Ponyfill for native Element.matches method\n *\n * @param {object} elm - The element to test\n * @param {string} selector - The CSS selector to test against\n * @returns {boolean}\n */\nfunction matchesSelector(elm, selector) {\n    /* istanbul ignore next */\n    const matches = elm.matches || elm.matchesSelector || elm.webkitMatchesSelector || elm.mozMatchesSelector || elm.msMatchesSelector || elm.oMatchesSelector;\n\n    return matches.call(elm, selector);\n}\n\n\n// Export\n// =============================================================================\nexport default getCssData;\n"],"names":["getUrls","urls","options","settings","mimeType","onComplete","Function","prototype","onError","onSuccess","urlArray","Array","isArray","urlQueue","apply","length","map","xhr","urlIndex","responseText","indexOf","forEach","url","i","parser","document","createElement","setAttribute","href","isCrossDomain","host","location","isSameProtocol","protocol","XDomainRequest","xdr","open","timeout","onprogress","ontimeout","onload","onerror","err","send","log","XMLHttpRequest","overrideMimeType","onreadystatechange","readyState","status","getCssData","regex","include","exclude","filter","sourceNodes","querySelectorAll","matchesSelector","node","cssArray","handleComplete","cssText","join","handleSuccess","cssIndex","sourceUrl","resolveImports","baseUrl","callbackFn","__errorData","__errorRules","importRules","replace","cssComments","match","cssImports","rule","importUrls","decl","getFullUrl","push","importText","importDecl","newCssText","resolvedCssText","errorData","data","test","returnVal","linkHref","getAttribute","linkRel","isLink","nodeName","toLowerCase","isStyle","textContent","base","d","implementation","createHTMLDocument","b","a","head","appendChild","body","elm","selector","matches","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","call"],"mappings":"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"}